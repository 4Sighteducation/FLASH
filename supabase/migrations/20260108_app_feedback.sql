-- App feedback submissions (supports multiple surveys over time via survey_key)
-- Safe to run multiple times.

create table if not exists public.app_feedback (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  survey_key text not null,
  user_id uuid null references auth.users(id) on delete set null,
  answers jsonb not null default '{}'::jsonb,
  meta jsonb not null default '{}'::jsonb,
  status text not null default 'new'
);

create index if not exists app_feedback_created_at_idx on public.app_feedback (created_at desc);
create index if not exists app_feedback_survey_key_idx on public.app_feedback (survey_key);
create index if not exists app_feedback_user_id_idx on public.app_feedback (user_id);

alter table public.app_feedback enable row level security;

-- Helper: app admins are defined by JWT email (matches client-side useAdminAccess.ts).
create or replace function public.is_app_admin()
returns boolean
language sql
stable
as $$
  select lower(coalesce(auth.jwt()->>'email', '')) = any (
    array[
      'tony@vespa.academy',
      'admin@vespa.academy',
      'tonyden10@gmail.com'
    ]
  );
$$;

alter function public.is_app_admin() set search_path = public;
revoke all on function public.is_app_admin() from public, anon;
grant execute on function public.is_app_admin() to authenticated;
grant execute on function public.is_app_admin() to service_role;

-- Anyone with the link can submit feedback (anon or authenticated).
do $$
begin
  if not exists (
    select 1
    from pg_policies
    where schemaname = 'public'
      and tablename = 'app_feedback'
      and policyname = 'app_feedback_insert_anyone'
  ) then
    create policy "app_feedback_insert_anyone"
      on public.app_feedback
      for insert
      to anon, authenticated
      with check (
        survey_key is not null
        and length(survey_key) between 3 and 64
      );
  end if;
end $$;

-- Only admins can view/triage submissions from the client app.
do $$
begin
  if not exists (
    select 1
    from pg_policies
    where schemaname = 'public'
      and tablename = 'app_feedback'
      and policyname = 'app_feedback_select_admin'
  ) then
    create policy "app_feedback_select_admin"
      on public.app_feedback
      for select
      to authenticated
      using (public.is_app_admin());
  end if;
end $$;

-- Optional: allow admins to update status (triage).
do $$
begin
  if not exists (
    select 1
    from pg_policies
    where schemaname = 'public'
      and tablename = 'app_feedback'
      and policyname = 'app_feedback_update_admin'
  ) then
    create policy "app_feedback_update_admin"
      on public.app_feedback
      for update
      to authenticated
      using (public.is_app_admin())
      with check (public.is_app_admin());
  end if;
end $$;

